* Python 기초 3: 파일 다루기, 함수, 클래스

** 파일 다루기

이번에는 파일을 읽고 쓰는 방법을 알아봅시다.

#+BEGIN_SRC python :results output :exports both
  fin = open('assets/day1-example-read.txt')
  content = fin.read()
  print(content, end='')
  fin.close()
#+END_SRC

#+RESULTS:
: ID,Sex,Age,Programming?,Python?
: 1,M,25,T,T
: 2,F,27,T,F
: 3,F,24,F,F
: 4,F,25,T,T
: 5,M,32,F,F
: 6,M,39,T,F

위의 코드를 살펴봅시다. ~open()~ 이라는 함수가 있고, 그 인자로 파일 경로를 전달합니다. 그러면 ~open()~ 함수는 파일 객체를 반환합니다. 파일 객체를 ~fin~ 이라는 이름의 변수에 담았고, 파일 객체의 메소드 중 ~read()~ 라는 메소드를 사용하여 파일의 내용을 모두 읽어들여 ~content~ 변수에 저장합니다. 파일을 모두 사용한 후에는 반드시 ~close()~ 메소드를 호출하여 파일을 닫아주어야 합니다.

위 예제는 아래와 같이 줄여서 쓸 수 있습니다.

#+BEGIN_SRC python :results output :exports both
  with open('assets/day1-example-read.txt') as fin:
        content = fin.read()
  print(content, end='')
#+END_SRC

#+RESULTS:
: ID,Sex,Age,Programming?,Python?
: 1,M,25,T,T
: 2,F,27,T,F
: 3,F,24,F,F
: 4,F,25,T,T
: 5,M,32,F,F
: 6,M,39,T,F

여기서 =with A as B= 구문이 등장하는데, =with= 구문은 자신의 범위를 벗어난 경우 적절한 리소스 반환 작업을 수행합니다. (모든 리소스에 =with= 구문을 사용할 수 있는 것은 아닙니다.)

파일이 작을 때는 위와 같은 방식으로 읽어들여도 좋지만, 파일이 매우 커서 메모리에 담을 수 없는 경우에는 한줄씩 읽어들여 처리하는 경우가 일반적입니다. 텍스트 파일을 열어 한줄씩 읽어들이는 구문은 아래와 같습니다. (아래 코드를 실행하기 전에, 먼저 파이썬 소스 파일과 같은 디렉토리에 =assets= 디렉토리를 만들고, [[file:assets/day1-example-read.txt][텍스트 파일]]을 =assets= 디렉토리 안에 저장해야 합니다.)

#+BEGIN_SRC python :results output :exports both
  fin = open('assets/day1-example-read.txt')
  for line in fin:
     print(line, end='')
  fin.close()
#+END_SRC

#+RESULTS:
: ID,Sex,Age,Programming?,Python?
: 1,M,25,T,T
: 2,F,27,T,F
: 3,F,24,F,F
: 4,F,25,T,T
: 5,M,32,F,F
: 6,M,39,T,F

=open= 함수에 대해 조금 더 살펴봅시다.

 - mode에 대해 설명. rt, rb, wt, wb 등.
 - encoding 옵션도.


 - read
 - write

=EUC-KR= 인코딩 옵션

#+BEGIN_SRC python :results output :exports both
  with open('assets/moon_speech_euckr.txt', encoding='euckr') as fin:
      print(fin.readline())
#+END_SRC

#+RESULTS:
: 존경하고 사랑하는 국민 여러분. 감사합니다. 국민 여러분의 위대한 선택에 머리 숙여 깊이 감사드립니다. 저는 오늘 대한민국 제 19대 대통령으로서 새로운 대한민국을 향해 첫걸음을 내딛습니다. 지금 제 두 어깨는 국민 여러분으로부터 부여받은 막중한 소명감으로 무겁습니다. 지금 제 가슴은 한번도 경험하지 못한 나라를 만들겠다는 열정으로 뜨겁습니다. 그리고 지금 제 머리는 통합과 공존의 새로운 세상을 열어갈 청사진으로 가득 차 있습니다.
: 


** 함수 (Function)

지금까지 프로그램을 만들기 위한 하나 하나의 조각들을 살펴봤다면, 이제는 그 조각들을 쌓아올리기 위해, 다시 말해서 구조화를 하기 위해서 필요한 도구들을 살펴봅시다.

우선, 가장 기본적인 도구로는 함수가 있습니다. 수학적인 측면에서 함수는 '어떤 입력 X에 대해 Y라는 값을 결과로 되돌려주는 것'이라고 표현할 수 있겠죠. 기하적으로 표현하면 'X의 한 점을 Y라는 점으로 변환(mapping)해주는 것'이라고 할 수 있겠고요.

Python에서는 아래와 같이 함수를 정의할 수 있습니다.

#+BEGIN_SRC python :results output
def add(x, y):
    return x + y

print(add(1, 3))
#+END_SRC

#+RESULTS:
: 4

위 함수는, x, y 라는 값을 받아서 둘을 더한 값을 반환해줍니다. 함수 정의 형식은 아래와 같이 표현할 수 있겠습니다.

#+BEGIN_SRC python :results output
def 함수이름(인자1, 인자2, 인자3, ...):
    # 내용
    return
#+END_SRC

하지만, 프로그래밍에서 함수는, 수학적인 의미에 더해서, '여러 개의 일련의 연관된 작업을 의미 있는 단위로 묶는다'는 의미를 가집니다. 이를테면 여러 연관된 문장을 묶은 뒤, 소제목을 붙인다고 할까요.

이전에 의미망 예제가 조금 복잡했었죠? 그걸 함수를 사용해서 묶어봅시다.


#+BEGIN_SRC python :results output :exports both
  import networkx as nx
  import matplotlib.pyplot as plt

  def construct_wordnet(text):
      lines = text.split('\n')      # 줄 단위로 자른다

      word_edges = {}

      for line in lines:
          _line = line.strip()
          if not _line:             # 빈줄이면 건너뛴다
              continue
          statements = _line.split('.') # 문장 단위로 자른다
          for statement in statements: # 빈 문장이면 건너뛴다
              if not statement:
                  continue
              words = statement.split(' ') # 단어 단위로 자른다
              cleansed_words = [w.replace('.', '').replace(',', '').strip() for w in words] # 단어에서 구두점이나 공백을 없앤다
              cleansed_words_2 = [w for w in cleansed_words if w] # 구두점 및 공백 제거로 인해 빈 문자열이 되어버린 원소를 제거한다
              num_words = len(cleansed_words_2)
              for index_i in range(num_words): # 한 문장에 등장한 단어들을 서로 연결한다
                  for index_j in range(index_i+1, num_words):
                      word_to_word = (cleansed_words_2[index_i], cleansed_words_2[index_j])
                      word_edges[word_to_word] = word_edges.setdefault(word_to_word, 0) + 1
      return word_edges

  def remove_low_frequency(word_edges, cutoff=2):
      # 등장 빈도가 1회인 edge는 제거한다
      keys = list(word_edges.keys())
      for key in keys:
          if word_edges[key] < cutoff:
              del word_edges[key]

  def draw_graph(word_edges):
      G = nx.Graph()
      for (word_1, word_2), freq in word_edges.items():
          G.add_edge(word_1, word_2, weight=freq)

      pos = nx.kamada_kawai_layout(G)
      plt.figure(figsize=(12, 12))    # 결과 이미지 크기를 크게 지정 (12inch * 12inch)
      widths = [G[node1][node2]['weight'] for node1, node2 in G.edges()]
      nx.draw_networkx_edges(G, pos, width=widths, alpha=0.1);
      nx.draw_networkx_labels(G, pos, font_family='Noto Sans CJK KR'); # 각자 시스템에 따라 적절한 폰트 이름으로 변경
#+END_SRC

크게 세 부분으로 나누었습니다. 

 - 텍스트로부터 의미망 데이터를 만들어내는 부분
 - 빈도가 적은 링크는 제거하는 부분
 - 그래프를 그리는 부분

그리고, 데이터를 파일로부터 읽어들이도록 변경해봅시다.


#+BEGIN_SRC python
  def read_file(path):
      with open(path) as fin:
          return fin.read()
#+END_SRC

#+BEGIN_SRC ipython :results output :exports none
  import networkx as nx
  import matplotlib.pyplot as plt

  def read_file(path):
      with open(path) as fin:
          return fin.read()

  def construct_wordnet(text):
      lines = text.split('\n')      # 줄 단위로 자른다

      word_edges = {}

      for line in lines:
          _line = line.strip()
          if not _line:             # 빈줄이면 건너뛴다
              continue
          statements = _line.split('.') # 문장 단위로 자른다
          for statement in statements: # 빈 문장이면 건너뛴다
              if not statement:
                  continue
              words = statement.split(' ') # 단어 단위로 자른다
              cleansed_words = [w.replace('.', '').replace(',', '').strip() for w in words] # 단어에서 구두점이나 공백을 없앤다
              cleansed_words_2 = [w for w in cleansed_words if w] # 구두점 및 공백 제거로 인해 빈 문자열이 되어버린 원소를 제거한다
              num_words = len(cleansed_words_2)
              for index_i in range(num_words): # 한 문장에 등장한 단어들을 서로 연결한다
                  for index_j in range(index_i+1, num_words):
                      word_to_word = (cleansed_words_2[index_i], cleansed_words_2[index_j])
                      word_edges[word_to_word] = word_edges.setdefault(word_to_word, 0) + 1
      return word_edges

  def remove_low_frequency(word_edges, cutoff=2):
      # 등장 빈도가 1회인 edge는 제거한다
      keys = list(word_edges.keys())
      for key in keys:
          if word_edges[key] < cutoff:
              del word_edges[key]
      return

  def draw_graph(word_edges):
      G = nx.Graph()
      for (word_1, word_2), freq in word_edges.items():
          G.add_edge(word_1, word_2, weight=freq)

      pos = nx.kamada_kawai_layout(G)
      plt.figure(figsize=(12, 12))    # 결과 이미지 크기를 크게 지정 (12inch * 12inch)
      widths = [G[node1][node2]['weight'] for node1, node2 in G.edges()]
      nx.draw_networkx_edges(G, pos, width=widths, alpha=0.1)
      nx.draw_networkx_labels(G, pos, font_family='Noto Sans CJK KR') # 각자 시스템에 따라 적절한 폰트 이름으로 변경
      return
#+END_SRC

이제 다양한 문서에 대해서 아래와 같은 몇 줄의 코드만으로 의미망을 출력할 수 있게 되었습니다.

#+BEGIN_SRC ipython :results raw :exports both :ipyfile outputs/moon_speech.png
  text = read_file('assets/moon_speech.txt')
  wordnet = construct_wordnet(text)
  remove_low_frequency(wordnet)
  draw_graph(wordnet)
  plt.show()
#+END_SRC

#+RESULTS:
[[file:outputs/moon_speech.png]]

박근혜 전 대통령 취임사에 대해서도 의미망을 살펴봅시다.

#+BEGIN_SRC ipython :results raw :exports both :ipyfile outputs/park_speech.png
  text = read_file('assets/park_speech.txt')
  wordnet = construct_wordnet(text)
  remove_low_frequency(wordnet)
  draw_graph(wordnet)
  plt.show()
#+END_SRC

#+RESULTS:
[[file:outputs/park_speech.png]]

박근혜 대통령은 좀 더 다양한 어휘를 사용한 것 같네요. =cutoff= 를 좀 더 강화해봅시다.

#+BEGIN_SRC ipython :results raw :exports both :ipyfile outputs/park_speech_2.png
  text = read_file('assets/park_speech.txt')
  wordnet = construct_wordnet(text)
  remove_low_frequency(wordnet, cutoff=3)
  draw_graph(wordnet)
  plt.show()
#+END_SRC

#+RESULTS:
[[file:outputs/park_speech_2.png]]

함수를 어떤 경우에 많이 사용하는지 실제 사례를 살펴보았습니다.

함수 자체에 대해서 조금 더 살펴봅시다.

*** Positional argument vs Keyword argument

앞의 예에서, ~remove_low_frequency()~ 함수의 인자 중 ~cutoff~ 인자가 약간 다르게 생긴 것을 볼 수 있습니다.

#+BEGIN_SRC python
  def remove_low_frequency(word_edges, cutoff=2):
      return
#+END_SRC

~word_edge~ 와 같은, ~=~ 표시가 없이 정의된 인자를 위치 인자라고 하고, ~cutoff~ 와 같이 ~=~ 표시와 함께 정의된 인자를 키워드 인자라고 합니다.

위치 인자는 위치에 의해서 변수가 할당됩니다. 아래와 같은 함수가 있다고 할 때, 주어지는 인자의 순서에 따라서 함수를 정의할 때 지정된 변수에 값이 들어갑니다.

#+BEGIN_SRC python :results output
  def positional(arg1, arg2):
      print('I am', arg1, arg2)

  positional('a', 'boy')
  positional('boy', 'a')
#+END_SRC

#+RESULTS:
: I am a boy
: I am boy a


반면, ~cutoff~ 와 같은 키워드 인자는 이름을 지정해서 부여할 수 있습니다. 이름을 부여하지 않으면 위치 인자와 동일하게 동작합니다.

#+BEGIN_SRC python :results output
  def keyword(kwarg1=None, kwarg2='girl'):
      print('I am', kwarg1, kwarg2)

  keyword('a', 'boy')
  keyword('a', kwarg2='boy')
  keyword(kwarg1='a', kwarg2='boy')
  keyword(kwarg2='boy', kwarg1='a')
  keyword(kwarg1='a')
#+END_SRC

#+RESULTS:
: I am a boy
: I am a boy
: I am a boy
: I am a boy
: I am a girl

또한, 위치 인자는 생략이 불가능하지만, 키워드 인자는 생략이 가능합니다. 키워드 인자를 생략할 경우, 함수를 정의할 때 지정했던 기본값이 변수에 할당됩니다.

그리고, 위치 인자와 키워드 인자를 하나의 함수 선언에 동시에 사용할 수 있습니다. 하지만 그 경우에는, 위치 인자를 앞쪽에, 그리고 키워드 인자를 뒷쪽에 선언해야 합니다. 키워드 인자가 위치 인자보다 앞에 선언될 수 없습니다.

#+BEGIN_SRC python :results output
def mixed(arg1, arg2, kwarg1='studying', kwarg2='excel'):
    print(arg1, arg2, kwarg1, kwarg2)

mixed('I', 'am', kwarg2='python')
#+END_SRC

#+RESULTS:
: I am studying python


#+BEGIN_SRC python
  def mixed2(kwarg0=None, arg1, arg2, kwarg1='studying', kwarg2='excel'): # 키워드 인자가 위치 인자의 앞에 선언될 수 없음
      return

  mixed('I')                      # 위치 인자는 생략할 수 없음 (arg2가 주어지지 않았음)
#+END_SRC

#+RESULTS:


*** Argument list unpacking

그런데 가만히 살펴보면, 위치 인자는 ~list~ 나 ~tuple~ 과 닮아있고, 키워드 인자는 ~dict~ 와 닮아있습니다. ~list~ 나 ~tuple~ 도 위치로만 각 원소를 지칭할 수 있고, ~dict~ 는 이름으로 부를 수 있습니다.

이런 특성을 활용해서, 인자를 직접 코드에 기재하지 않고도, ~list~ 나 ~tuple~, ~dict~ 를 사용해서 부여할 수 있습니다.

#+BEGIN_SRC python :results output
def mixed(arg1, arg2, kwarg1='studying', kwarg2='excel'):
    print(arg1, arg2, kwarg1, kwarg2)

args = ['I', 'am']
mixed(*args)

args = ['We', 'are']
mixed(*args)

kwargs = {'kwarg2': 'python'}
mixed(*args, **kwargs)
#+END_SRC

#+RESULTS:
: I am studying excel
: We are studying excel
: We are studying python

위와 같이, 위치 인자로 전달할 값들을 ~list~ 나 ~tuple~ 에 넣고, 함수에 넣어줄 때는 변수 이름 앞에 ~*~ 을 붙여주면, ~,~ 를 사용해서 연속된 값을 넣어준 것과 같은 효과가 납니다.

비슷하게, 키워드 인자로 전달할 값들을 ~dict~ 에 인자의 이름과 함께 넣고, 변수 이름 앞에 ~**~ 를 붙여주면, 이름을 지정해서 값을 넣어준 것과 같은 효과가 납니다.


*** First-class function & lambda function

다음으로 살펴볼 것은, 일급 함수 언어로서의 특성입니다. first-class function 이라고 하는데, 함수를 일급 시민으로 취급한다는 이야기입니다. 프로그래밍 언어에서 일급 시민으로 취급한다는 이야기는, 함수를 변수에 저장하거나 함수의 인자로 전달하는 등, 일반적인 값처럼 동일하게 다룰 수 있다는 것을 뜻합니다.

설명하자면 복잡하니, 다음 예를 보시죠.


** 클래스 (Class)

다음으로 살펴볼 것은 클래스입니다. 클래스는 기본적으로 함수와 비슷한데, 여러 개의 함수가 하나의 묶음으로 묶여있는 것이 특징입니다. 클래스로 묶여있는 함수를 메소드(method)라고 부릅니다. 뿐만 아니라, 하나의 클래스 안에는 여러 함수들에서 공통적으로 사용하는 변수들이 존재합니다.

기본적으로, 클래스는 아래와 같이 정의하고 사용합니다.


#+BEGIN_SRC python :results output :exports both
  class Wordnet:
     def __init__(self, content):
        self.content = content
        self.wordnet = construct_wordnet(self.content)

     def draw(self):
        draw_graph(wordnet)
#+END_SRC


** 연습문제

뭘 할까...?

 - 설문조사한 것 통계내기?
   - 성별에 따른 프로그래밍 경험 유무 빈도 및 비율
   - 연령대에 따른 프로그래밍 경험 유무 빈도 및 비율
   - 프로그래밍 경험 유무에 따른 파이썬 경험 유무 비율
 - 웹 크롤링?

if, for, encoding
